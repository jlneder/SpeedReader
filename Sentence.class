package com.speedreader;

import java.util.*;
import java.io.File;
import java.io.IOException;
/**
 * - Contains an arraylists of chunks
 * - Chunks the sentences
 *   - chunks based off of punctuation marks, conjunctions, and prepositions
 * - Breaks down chunks that are too large 
 * - Parses up chunks that are too small
 * 
 * Using set allows for quick lookup
 */
public class Sentence {
//	private static String COMMA = ",";
	private static String COLON = ":";
	private static String SEMI_COLON = ";";
	private static String LEFT_PARENTH = "(";
	private static String RIGHT_PARENTH = ")";
	private static char QUOTE = '"';
	private static int SPECIAL_BIG_DASH = 8212;
	private static int LEFT_SPECIAL_DOUBLEQUOTE = 8220;
	private static int RIGHT_SPECIAL_DOUBLEQUOTE = 8221;
	
    private String sentence;
    private Scanner in;
    private ArrayList<Chunk> chunks;
    private Set<String> prepositions;
    private Set<String> conjunctions;
    private int upperbound;
    private int lowerbound;
    private int desired_length;
    /**
     * Constructor
     * - loads preposistions
     * - sentence -> array of words
     * 
     */
    public Sentence(String sentence, int desired_length) {
        this.sentence = sentence;
        this.desired_length = desired_length;
        chunks = new ArrayList<Chunk>();
        prepositions = new HashSet <String>();
        conjunctions = new HashSet <String>();

        upperbound = 0;
        lowerbound = 0;

        //System.out.println(sentence + "*");

        
        loadPrepositions();
        loadConjunctions();
        chunkSentence();
        breakDown(desired_length);
        parseUp();

    }

    /**
     *  .txt -> Set (String)
     *  interp. loads all prepositions from temp into set
     *  
     *  allows words to be checked quickly
     */
    public void loadPrepositions(){
        try{
            in = new Scanner(new File("prep.txt"));
        }catch(IOException i){
            System.out.println("Error: " + i.getMessage());
        }

        String text = "";
        while(in.hasNextLine()){
            text = in.nextLine();
            prepositions.add(text);
        }

        

    }

    /**
     *  Loading Conjunctions into a Hash Set for fast look up
     */
    public void loadConjunctions(){
        try{
            in = new Scanner(new File("conjunctions.txt"));
        }catch(IOException i){
            System.out.println("Error: " + i.getMessage());
        }

        String text = "";
        while(in.hasNextLine()){
            text = in.nextLine();
            conjunctions.add(text);
        }

        
    }

    /**
     * Sentence -> Chunk
     * 
     * adds chunks to the chunks(arraylist)
     * 
     *  - 1. commas
     *  - 2. prepositions
     *  
     *  NOTE:
     *  To avoid ConcurrentModifierException
     *  temp_chunks and chunks are used interchangably
     */
    public void chunkSentence(){
        ArrayList<Chunk> temp_chunks = new ArrayList<Chunk>(); // to avoid concurrent modifier exception
        String temp = sentence;

        // ---- Main Subphrase
        // -- Commas, SemiColon, Colon, parenthesis, quotes

        int commaIndex = temp.indexOf(Punctuation.COMMA.character());
        int colonIndex = temp.indexOf(Punctuation.COLON.character());
        int semiColonIndex = temp.indexOf(Punctuation.SEMICOLON.character());
        int dashIndex = temp.indexOf(Punctuation.DASH.character());
        int leftParenthIndex = temp.indexOf(Punctuation.LEFT_PARENTH.character());
        int rightParenthIndex = temp.indexOf(Punctuation.RIGHT_PARENTH.character());
        int quoteIndex = temp.indexOf(Punctuation.QUOTE.character());
        int leftQuoteIndex = temp.indexOf(Punctuation.LEFT_QUOTE.character());
        int rightQuoteIndex = temp.indexOf(Punctuation.RIGHT_QUOTE.character());
        
        while(temp.indexOf(Punctuation.COMMA.character()) > -1 || temp.indexOf(Punctuation.COLON.character()) > -1 || 
        temp.indexOf(Punctuation.SEMICOLON.character()) > -1 || temp.indexOf(Punctuation.DASH.character()) > -1 ||
        temp.indexOf(Punctuation.LEFT_PARENTH.character()) > -1 || temp.indexOf(Punctuation.RIGHT_PARENTH.character()) > -1 ||
        temp.indexOf(Punctuation.QUOTE.character()) > -1 || temp.indexOf(Punctuation.RIGHT_QUOTE.character()) > -1 || 
        temp.indexOf(Punctuation.LEFT_QUOTE.character()) > -1){
            

            // add in left quote and regular quote. 
            // commas
            
            System.out.println(temp);
            
            
            
            
            
            
            Punctuation punctuation = findEarlistPunctuation(commaIndex, colonIndex, semiColonIndex, dashIndex, leftParenthIndex, 
            												rightParenthIndex, quoteIndex, leftQuoteIndex, rightQuoteIndex);

            switch(punctuation){
            
            case COMMA:
            	Chunk ch1 = createCommaChunk(temp, commaIndex);
            	temp =  temp.substring(ch1.getLength());
            	temp_chunks.add(ch1);
            	break;
            case COLON:
            	Chunk ch2 = createNormalChunk(temp, colonIndex);
            	temp =  temp.substring(ch2.getLength());
            	temp_chunks.add(ch2);
            	break;
            case SEMICOLON:
            	Chunk ch3 = createNormalChunk(temp, semiColonIndex);
            	temp =  temp.substring(ch3.getLength());
            	temp_chunks.add(ch3);
            	break;
            case DASH:
            	Chunk ch4 = createNormalChunk(temp, dashIndex);
            	temp =  temp.substring(ch4.getLength());
            	temp_chunks.add(ch4);
            	break;
            case LEFT_PARENTH:
            	Chunk ch5 = createSpecialLeftChunk(temp, leftParenthIndex);
            	temp =  temp.substring(ch5.getLength());
            	temp_chunks.add(ch5);
            	break;
            case RIGHT_PARENTH:
            	Chunk ch6 = createNormalChunk(temp, rightParenthIndex);
            	temp =  temp.substring(ch6.getLength());
            	temp_chunks.add(ch6);
            	break;
            case QUOTE:
            	Chunk ch7 = createQuoteChunk(temp, quoteIndex);
            	temp =  temp.substring(ch7.getLength());
            	temp_chunks.add(ch7);
            	break;
            case LEFT_QUOTE:
            	Chunk ch8 = createSpecialLeftChunk(temp, leftQuoteIndex);
            	temp =  temp.substring(ch8.getLength());
            	temp_chunks.add(ch8);
            	break;
            case RIGHT_QUOTE: 
            	Chunk ch9 = createNormalChunk(temp, rightQuoteIndex);
            	temp =  temp.substring(ch9.getLength());
            	temp_chunks.add(ch9);
            	break;
			default:
				System.out.println("DID NOTHING");
				break;
            
            }
            
            
            
            
            
            
            
            
            
            /*
            if((comma < colon || colon == -1) && 
            (comma < semi_colon || semi_colon == -1) && 
            (comma < dash || dash == -1) &&
            (comma < left_parenth || left_parenth == -1 || left_parenth == 0) &&
            (comma < right_parenth || right_parenth == -1) &&
            (comma < quote || quote == -1 || quote == 0) &&
            (comma < left_quote || left_quote == -1 || left_quote == 0) &&
            (comma < right_quote || right_quote == -1) &&
            comma != -1){
                System.out.println("------------Commas-----------");

                if(temp.charAt(comma + 1) == ' '){
                    temp_chunks.add(new Chunk(temp.substring(0, temp.indexOf(",") + 2)));
                    temp = temp.substring(temp.indexOf(",") + 1);
                }
                else if((temp.charAt(comma + 1) == '"') || ((int)temp.charAt(comma + 1) == RIGHT_SPECIAL_DOUBLEQUOTE)){
                    temp_chunks.add(new Chunk(temp.substring(0, temp.indexOf(",") + 3)));
                    temp = temp.substring(temp.indexOf(",") + 2);
                }
            }    //colon
            else if((colon < comma || comma == -1) && 
            (colon < semi_colon || semi_colon == -1) && 
            (colon < dash || dash == -1) &&
            (colon < left_parenth || left_parenth == -1 || left_parenth == 0) &&
            (colon < right_parenth || right_parenth == -1) &&
            (colon < quote || quote == -1 || quote == 0) &&
            (colon < left_quote || left_quote == -1 || left_quote == 0) &&
            (colon < right_quote || right_quote == -1) &&
            colon != -1){
                System.out.println("------------Colon-----------");
                temp_chunks.add(new Chunk(temp.substring(0, temp.indexOf(":") + 2)));
                temp = temp.substring(temp.indexOf(":") + 1);
            }    // semi colon
            else if((semi_colon < comma || comma == -1) && 
            (semi_colon < colon || colon == -1) && 
            (semi_colon < dash || dash == -1) &&
            (semi_colon < left_parenth || left_parenth == -1 || left_parenth == 0) &&
            (semi_colon < right_parenth || right_parenth == -1) &&
            (semi_colon < quote || quote == -1 || quote == 0) &&
            (semi_colon < left_quote || left_quote == -1 || left_quote == 0) &&
            (semi_colon < right_quote || right_quote == -1) &&
            semi_colon != -1){
                System.out.println("------------SemiColon-----------");
                temp_chunks.add(new Chunk(temp.substring(0, temp.indexOf(";") + 2)));
                temp = temp.substring(temp.indexOf(";") + 1);
            }    // dash
            else if((dash < comma || comma == -1) &&
            (dash < colon || colon == -1) && 
            (dash < semi_colon || semi_colon == -1) && 
            (dash < left_parenth || left_parenth == -1 || left_parenth == 0) &&
            (dash < right_parenth || right_parenth == -1) &&
            (dash < quote || quote == -1 || quote == 0) &&
            (dash < left_quote || left_quote == -1 || left_quote == 0) &&
            (dash < right_quote || right_quote == -1) &&
            dash != -1){
                System.out.println("------------Dash-----------");
                temp_chunks.add(new Chunk(temp.substring(0, temp.indexOf((char)SPECIAL_BIG_DASH) + 2)));
                temp = temp.substring(temp.indexOf((char)SPECIAL_BIG_DASH) + 1);
            }    // left parenthesis
            else if((left_parenth < colon || colon == -1) && 
            (left_parenth < semi_colon || semi_colon == -1) && 
            (left_parenth < dash || dash == -1) &&
            (left_parenth < comma || comma == -1) &&
            (left_parenth < right_parenth || right_parenth == -1) &&
            (left_parenth != -1) &&
            (left_parenth < quote || quote == -1 || quote == 0) &&
            (left_parenth < left_quote || left_quote == -1 || left_quote == 0) &&
            (left_parenth < right_quote || right_quote == -1) &&
            (left_parenth != 0)){
                System.out.println("------------LeftParenthesis-----------");
                temp_chunks.add(new Chunk(temp.substring(0, temp.indexOf("("))));
                temp = temp.substring(temp.indexOf("("));
                //System.out.println(temp);
            }   // right parenth
            else if((right_parenth < colon || colon == -1) && 
            (right_parenth < semi_colon || semi_colon == -1) && 
            (right_parenth < dash || dash == -1) &&
            (right_parenth < left_parenth || left_parenth == -1 || left_parenth == 0) &&
            (right_parenth < comma || comma == -1) &&
            (right_parenth < quote || quote == -1 || quote == 0) &&
            (right_parenth < left_quote || left_quote == -1 || left_quote == 0) &&
            (right_parenth < right_quote || right_quote == -1) &&
            (right_parenth != -1)){
                System.out.println("------------RightParenthesis-----------");

                if(temp.charAt(right_parenth + 1) == ' '){
                    temp_chunks.add(new Chunk(temp.substring(0, right_parenth + 2)));
                    temp = temp.substring(right_parenth + 1);
                }
                else if((temp.charAt(right_parenth + 1) == ',')){
                    temp_chunks.add(new Chunk(temp.substring(0, right_parenth + 3)));
                    temp = temp.substring(right_parenth + 2);
                }
                else{
                    temp_chunks.add(new Chunk(temp.substring(0, right_parenth + 1)));
                    temp =  temp.substring(right_parenth + 1);
                }
            }
            else if((quote < comma || comma == -1) && 
            (quote < semi_colon || semi_colon == -1) && 
            (quote < dash || dash == -1) &&
            (quote < left_parenth || left_parenth == -1 || left_parenth == 0) &&
            (quote < right_parenth || right_parenth == -1) &&
            (quote < colon || colon == -1) &&
            (quote < left_quote || left_quote == -1) &&
            (quote < right_quote || right_quote == -1) &&
            (quote != -1) &&
            (quote != 0)){
                System.out.println("------------Quote-----------");

                /// BUG HERE!
                if(temp.charAt(quote - 1) == ' '){
                    temp_chunks.add(new Chunk(temp.substring(0, quote)));
                    temp = temp.substring(quote);
                    System.out.println("------------Left----------");
                    System.out.println(temp);
                }
                else{
                    temp_chunks.add(new Chunk(temp.substring(0, quote + 2)));
                    temp = temp.substring(quote + 2);
                    System.out.println("------------Right----------");
                }
                //System.out.println("HI");
            }
            else if((left_quote < comma || comma == -1) && 
            (left_quote < semi_colon || semi_colon == -1) && 
            (left_quote < dash || dash == -1) &&
            (left_quote < left_parenth || left_parenth == -1 || left_parenth == 0) &&
            (left_quote < right_parenth || right_parenth == -1) &&
            (left_quote < quote || quote == -1 || quote == 0) &&
            (left_quote < colon || colon == -1) &&
            (left_quote < right_quote || right_quote == -1) &&
            (left_quote != -1) &&
            (left_quote != 0)){
                System.out.println("------------LeftQuote-----------");
                temp_chunks.add(new Chunk(temp.substring(0, temp.indexOf((char)LEFT_SPECIAL_DOUBLEQUOTE))));
                temp = temp.substring(temp.indexOf((char)LEFT_SPECIAL_DOUBLEQUOTE));
                //System.out.println("HI");
            }
            else if((right_quote < comma || comma == -1) && 
            (right_quote < semi_colon || semi_colon == -1) && 
            (right_quote < dash || dash == -1) &&
            (right_quote < left_parenth || left_parenth == -1 || left_parenth == 0) &&
            (right_quote < right_parenth || right_parenth == -1) &&
            (right_quote < quote || quote == -1 || quote == 0) &&
            (right_quote < left_quote || left_quote == -1 || left_quote == 0) &&
            (right_quote < colon || colon == -1) &&
            right_quote != -1){
                System.out.println("------------RightQuote-----------");
                temp_chunks.add(new Chunk(temp.substring(0, temp.indexOf((char)RIGHT_SPECIAL_DOUBLEQUOTE) + 2)));
                temp = temp.substring(temp.indexOf((char)RIGHT_SPECIAL_DOUBLEQUOTE) + 1);
                //System.out.println("HI");
            }

            // ignore left_quote and quote when it begins. 
            // 
            if((quote == 0 || left_quote == 0) &&
            (comma == -1) &&
            (semi_colon == -1) &&
            (colon == -1) &&
            (dash == -1) &&
            (left_parenth == -1) &&
            (right_parenth == -1) &&
            (right_quote == -1))
            {
                break;
            }
            */

            //System.out.println("BUG");
            // BUG
        }
        temp_chunks.add(new Chunk(temp));

        // Punctuation Tester 

        for(Chunk chunk:temp_chunks){
            System.out.println(chunk.getText());
        }

        // ---- Conjunctions

        int num_conj = 0;
        for(Chunk chunk:temp_chunks){
            String chunk_text = chunk.getText().trim();
            for(String word:chunk.getWords()){
                // check if conjunction
                int conj_pos = chunk_text.indexOf(word);
                if(conjunctions.contains(word)){
                    System.out.println(chunk_text);
                    System.out.println(word);
                    System.out.println(conj_pos);
                    if((conj_pos == 0) && 
                    (chunk_text.substring(word.length() + 1).indexOf(word) > -1)){
                        // making variations to chunk_text to avoid re looking up the first word
                        // ex. found 2nd "and" in "and played with his brothers and sisters all day"
                        conj_pos = chunk_text.substring(word.length() + 1).indexOf(word) + word.length() + 1;
                        //conj_pos -= word.length();
                        if((chunk_text.charAt(conj_pos - 1) == ' ') &&
                        (chunk_text.charAt(conj_pos + word.length()) == ' ')){
                            System.out.println("INSIDE");
                            chunks.add(new Chunk(chunk_text.substring(0, conj_pos)));
                            chunk_text = chunk_text.substring(conj_pos);
                        }
                    }
                    else if((conj_pos == chunk_text.length() - word.length()) ||
                    (conj_pos == 0) || 
                    ((chunk_text.charAt(conj_pos - 1) == ' ') &&
                        (chunk_text.charAt(conj_pos + word.length()) == ' '))){
                        System.out.println("OUTSIDE");
                        chunks.add(new Chunk(chunk_text.substring(0, chunk_text.indexOf(word))));
                        chunk_text = chunk_text.substring(conj_pos);
                    }
                }
                //System.out.println(conjunctions.contains(word));
            }
            chunks.add(new Chunk(chunk_text));
        }

        System.out.println("Number of Conjuctions detected: " + num_conj);
        temp_chunks.clear();
        // clearing all the chunks that have nothing 
        for(Chunk chunk: chunks){
            if(!chunk.isEmpty()){
                temp_chunks.add(chunk);
            }
        }
        chunks.clear();        
        // Printing Conj Chunks
        System.out.println("************Printing Conj Splits*****************");
        for(Chunk chunk: temp_chunks){
            System.out.println(chunk.getText());
        }
        System.out.println("************End Conj Splits*****************");
        // clear the temp arraylist to use again for prepositions

        // ---- Prepositions
        // temp_chunks -> chunks
        int temp_prep_pos = 0;
        int prep_pos = 0;
        for(Chunk chunk:temp_chunks){
            String chunk_text = chunk.getText();
            for(String word:chunk.getWords()){
                //if a preposition and not just a prep inside word. ex.  'as' in 'was'
                prep_pos = chunk_text.indexOf(" " + word + " ") + 1;
                temp_prep_pos = 0;
                if(prepositions.contains(word)){ 

                    //System.out.println(word);
                    //System.out.println(prep_pos);
                    /// NEEDS RETYPING

                    // gets the new conjunction

                    if(prep_pos == 0){
                        // if there is another instance of that word, split it there
                        temp_prep_pos = (chunk_text.substring(word.length() + 1).indexOf(word));
                        if((temp_prep_pos > -1) &&
                        (chunk_text.charAt(temp_prep_pos - 1) == ' ') && 
                        (chunk_text.charAt(temp_prep_pos + word.length()) == ' ')){
                            prep_pos = temp_prep_pos;
                            chunks.add(new Chunk(chunk_text.substring(0, prep_pos)));

                            //System.out.println(chunk_text.substring(0, prep_pos));

                            chunk_text = chunk_text.substring(prep_pos);

                        }
                        
                    }
                    else if((prep_pos > 0) &&
                    (chunk_text.indexOf(" " + word + " ") > -1)){
                        prep_pos = chunk_text.indexOf(" " + word + " ") + 1;
                        chunks.add(new Chunk(chunk_text.substring(0, prep_pos)));
                        chunk_text = chunk_text.substring(prep_pos);
                    }

                }
            }
            chunks.add(new Chunk(chunk_text));
            //System.out.println(chunk_text);
        }

        // get rid of old chunks and update
        temp_chunks.clear();
        for(Chunk chunk: chunks){
            if(!chunk.isEmpty()){
                temp_chunks.add(chunk);
            }
        }

        // Testing Chunks
        System.out.println();
        System.out.println("----Printing Prep Splits----");

        for(Chunk chunk:temp_chunks){
            System.out.println(chunk.getText());
            //System.out.println(chunk.getText().length());
        }

        //System.out.print(prepositions.contains("on"));

        System.out.println("----Printing Ending----");
        System.out.println();
        
    }
    

    private Chunk createQuoteChunk(String temp, int quote) {
    	
    	if(temp.charAt(quote - 1) == ' '){
            return new Chunk(temp.substring(0, quote));
        }
        else{
            return new Chunk(temp.substring(0, quote + 2));
        }
	}

	private Chunk createSpecialLeftChunk(String temp, int left_symbol) {
		return new Chunk(temp.substring(0, left_symbol));
        //temp = temp.substring(temp.indexOf("("));
		
	}

	private Chunk createNormalChunk(String temp, int symbol) {
		return new Chunk(temp.substring(0, symbol + 2));
        //temp = temp.substring(temp.indexOf(":") + 1);
	}

	private Chunk createCommaChunk(String temp, int comma) {
		if(temp.charAt(comma + 1) == ' '){
            return new Chunk(temp.substring(0, comma + 2));
            //temp = temp.substring(temp.indexOf(",") + 1);
        }
        else if((temp.charAt(comma + 1) == '"') || ((int)temp.charAt(comma + 1) == RIGHT_SPECIAL_DOUBLEQUOTE)){
            return new Chunk(temp.substring(0, comma + 3));
            //temp = temp.substring(temp.indexOf(",") + 2);
        }
		return null;
		
	}

	private Punctuation findEarlistPunctuation(int comma, int colon, int semi_colon,
			int dash, int left_parenth, int right_parenth, int quote,
			int left_quote, int right_quote) {
    	
		HashMap<String, Integer> map = new HashMap<String, Integer>();
		map.put("comma", comma);
		map.put("colon", colon);
		map.put("semi_colon", semi_colon);
		map.put("dash", dash);
		map.put("right_parenth", right_parenth);
		map.put("right_quote", right_quote);
		
		if(left_parenth > 0){
			map.put("left_parenth", left_parenth);
		}
		if(quote > 0){
			map.put("quote", quote);
		}
		if(left_quote > 0){
			map.put("left_quote", left_quote);
		}
		
		String smallest = null;
		int num = 100000;
		for(String key: map.keySet()){
			int value = map.get(key);
			if(value < num ||
					value != -1){
				smallest = key;
				num =  value;
			}
		}
		
		return getPunctuation(smallest);
		
		
		
		
		
	}

	private Punctuation getPunctuation(String smallest) {
		Punctuation punct = null;
		if(smallest.equals("comma")){
			punct = Punctuation.COMMA;
		}
		else if(smallest.equals("colon")){
			punct = Punctuation.COLON;
		}
		else if(smallest.equals("semi_colon")){
			punct = Punctuation.SEMICOLON;
		}
		else if(smallest.equals("dash")){
			punct = Punctuation.DASH;
		}
		else if(smallest.equals("right_parenth")){
			punct = Punctuation.RIGHT_PARENTH;
		}
		else if(smallest.equals("right_quote")){
			punct = Punctuation.RIGHT_QUOTE;
		}
		else if(smallest.equals("quote")){
			punct = Punctuation.QUOTE;
		}
		else if(smallest.equals("left_parenth")){
			punct = Punctuation.LEFT_PARENTH;
		}
		else if(smallest.equals("left_quote")){
			punct = Punctuation.LEFT_QUOTE;
		}
		
		return punct;
		
	}

	public String getSentence(){
        return sentence;
    }

    public ArrayList<Chunk> getChunks(){
        return chunks;
    }

    public void breakDown(int max_words){
        ArrayList<Chunk> temp_chunks = new ArrayList<Chunk>();
        String chunk_text;
        int chunk_length;
        int temp = 0;
        int num_chunks = 0;

        double ratio = 0.0;
        int split_pos = 0;
        int nearest_space = 0;
        int compare = 0;
        for(Chunk chunk: chunks){
            chunk_text = chunk.getText();
            chunk_length = chunk_text.length();
            temp = 0;
            if(chunk.getNumWords() > max_words){
                // determines how many chunks will be made
                if((chunk.getNumWords() / (double)(max_words)) > 2){
                    if(((int)(((double)(chunk.getNumWords()) / max_words) + 0.5) == chunk.getNumWords()/max_words))
                        num_chunks = chunk.getNumWords()/max_words;

                    else
                        num_chunks = (chunk.getNumWords() / max_words) + 1;
                }
                else
                    num_chunks = 2;

                for(int i= 1; i< num_chunks; i++){
                    ratio = ((double)(i)) / num_chunks;
                    split_pos = (int)(ratio * chunk_length);
                    nearest_space = 1000000; // set to arbitrary high number 
                    compare = 1000000;
                    for(int space_pos: chunk.getSpacePositions()){
                        // find nearest sapce
                        if(Math.abs(space_pos - split_pos) < compare){
                            //System.out.println("CHANGED");
                            nearest_space = space_pos;
                            compare = Math.abs(space_pos - split_pos);
                        }
                    }

                    temp_chunks.add(new Chunk(chunk_text.substring(0, nearest_space - temp + 1)));
                    chunk_text = chunk_text.substring(nearest_space - temp + 1);
                    temp = nearest_space;

                }
                temp_chunks.add(new Chunk(chunk_text));
            }
            else{
                temp_chunks.add(chunk);
            }
        }

        chunks.clear();

        for(Chunk chunk: temp_chunks){
            chunks.add(chunk);
        }

    }
    /**
     *  interp: Parses the chunks arraylsit, starting from the smallest.
     */
    public void parseUp(){
        int average_word_length = 4;
        int average_chunk_length = average_word_length * desired_length;
        upperbound = average_chunk_length + average_word_length;
        lowerbound = average_chunk_length - average_word_length;
        int present = 0;

        System.out.println("PRINTING NEW BROKEN CHUNKS");
        for(Chunk chunk: chunks){
            System.out.println(chunk.getText());
        }

        
        if(chunks.size() > 1){
            while(!allInBounds(chunks)){
                Chunk new_chunk;
                present = chunks.indexOf(getSmallest(chunks));

                //System.out.println("Length of Chunks: " + chunks.size());
                //System.out.println("Average Chunk Length: " + average_chunk_length);
                System.out.println();
                for(int i = 0; i < average_chunk_length; i++){
                    System.out.print("a");
                }
                System.out.println();

                for(Chunk chunk: chunks){
                    System.out.println(chunk.getText());
                }

                System.out.println();
                System.out.println("Smmallest Chunk: " +  chunks.get(present).getText());

                System.out.println();
                System.out.println("Modifying Chunk");
                if(present == 0){
                    // if the smallest is the first, there is no choice then to add to the second

                    new_chunk = new Chunk(chunks.get(present).getText() + " " + chunks.get(present + 1).getText());

                    System.out.println(new_chunk.getText());

                    chunks.remove(present + 1);
                    chunks.remove(present);
                    chunks.add(0, new_chunk);
                }
                else if(present == chunks.size() - 1){
                    // if the smallest is the last, you must add to the second to last
                    new_chunk = new Chunk(chunks.get(present - 1).getText() + " " + chunks.get(present).getText());

                    System.out.println(new_chunk.getText());

                    chunks.remove(present);
                    chunks.remove(present - 1);
                    chunks.add(new_chunk);
                }
                // else it is in the middle
                else{
                    Chunk combo1 = new Chunk(chunks.get(present - 1).getText() + " " + chunks.get(present).getText());
                    Chunk combo2 = new Chunk(chunks.get(present).getText() + " " + chunks.get(present + 1).getText());

                    // if both are inbounds, compare
                    if(combo1.inBounds(lowerbound, upperbound) && combo2.inBounds(lowerbound, upperbound)){
                        // make combo1
                        if(Math.abs(average_chunk_length - combo1.getLength()) < Math.abs(average_chunk_length - combo2.getLength())){
                            chunks.remove(present);
                            chunks.remove(present - 1);
                            chunks.add(present - 1, combo1);

                            System.out.println(combo1.getText());
                        }
                        else{
                            chunks.remove(present + 1);
                            chunks.remove(present);
                            chunks.add(present, combo2);

                            System.out.println(combo2.getText());
                        }
                    }
                    else if(combo1.inBounds(lowerbound, upperbound)){
                        chunks.remove(present);
                        chunks.remove(present - 1);
                        chunks.add(present - 1, combo1);

                        System.out.println(combo1.getText());
                    }
                    else if(combo2.inBounds(lowerbound, upperbound)){
                        chunks.remove(present + 1);
                        chunks.remove(present);
                        chunks.add(present, combo2);

                        System.out.println(combo2.getText());
                    } // none of the combos are inbounds, take the smaller one.
                    else{
                        // check if all three combined are applicable
                        Chunk combo3 = new Chunk(chunks.get(present - 1).getText() + " " + chunks.get(present).getText() + " " + chunks.get(present+1).getText());
                        if(combo3.inBounds(lowerbound, upperbound)){

                            chunks.remove(present + 1);
                            chunks.remove(present);
                            chunks.remove(present - 1);
                            chunks.add(present - 1, combo3);
                            System.out.println(combo3.getText());
                        } 

                        // check all combos and compare
                        else{
                            System.out.println("CHECKING");
                            //chunks.add(present + 1);

                            if(Math.abs(average_chunk_length - combo3.getLength()) <= Math.abs(average_chunk_length - combo1.getLength()) &&
                            (Math.abs(average_chunk_length - combo3.getLength()) <= Math.abs(average_chunk_length - combo2.getLength()))){
                                chunks.remove(present + 1);
                                chunks.remove(present);
                                chunks.remove(present - 1);
                                chunks.add(present - 1, combo3);  

                                System.out.println(combo3.getText());
                            }// combo1 is closer to average
                            else if(Math.abs(average_chunk_length - combo1.getLength()) <= Math.abs(average_chunk_length - combo3.getLength()) &&
                            (Math.abs(average_chunk_length - combo1.getLength()) <= Math.abs(average_chunk_length - combo2.getLength()))){
                                chunks.remove(present);
                                chunks.remove(present - 1);
                                chunks.add(present - 1, combo1);

                                System.out.println(combo1.getText());
                            }// combo2 is closer to average
                            else if(Math.abs(average_chunk_length - combo2.getLength()) <= Math.abs(average_chunk_length - combo1.getLength()) &&
                            (Math.abs(average_chunk_length - combo2.getLength()) <= Math.abs(average_chunk_length - combo3.getLength()))){
                                chunks.remove(present + 1);
                                chunks.remove(present);
                                chunks.add(present, combo2);

                                System.out.println(combo2.getText());
                            }

                        }
                    }
                }
            }
        }
    }

    /**
     * gets the smallest chunk that is out of bounds
     *  - if all are inbounds, return null
     * 
     * ArrayList<Chunk> -> Chunk, null
     */
    public Chunk getSmallest(ArrayList<Chunk> list){
        Chunk smallest_chunk = null;

        for(Chunk chunk: list){
            // if the chunk is out of bounds and is the smallest
            // if the chunk is larger than the upperbounds, leave it
            if((smallest_chunk == null) || 
            (!(chunk.inBounds(lowerbound, upperbound)) && chunk.getLength() < smallest_chunk.getLength()))
            {
                //System.out.println(chunk.getText());
                smallest_chunk = chunk;
            }
        }

        return smallest_chunk;
    }

    /**
     *  Checks if most of the chunks are inbounds
     *   - 80%
     */
    public boolean allInBounds(ArrayList<Chunk> list){
        for(Chunk chunk: list){
            if(!chunk.inBounds(lowerbound, upperbound) && chunk.getLength() < upperbound){
                return false;
            }
        }
        return true;
    }

}

